\chapter{Implementation}\label{chapter:implementation}

The discussed algorithms of \cref{chapter:algorithms} were implemented to analyze the performance. In order to have graphs on which the performance can be verified, some of the hypergraph creation algorithms of \cref{chapter:random_hypergraphs} were implemented as well. This chapter shall give an overview over the used technologies and the structure of the code.

\section{Technologies}
The focus of the implementation is less on fast execution time but on demonstrating feasibility of the algorithms. Therefore, Python 3 in combination with several libraries is utilized.
For vector representation and operations, NumPy \cite{numpy} proved useful and is therefore used. In order to optimize the semidefinite programming problem SDP \ref{SDP}, the commonly used SciPy \cite{scipy} was chosen over less commonly used tools like cvxpy or cvxopt as an implementation using them proved problematic due to lack of information resources about them.
For storing the results of the evaluation on graphs, Pickle is employed. In order to plot the graphs, Matplotlib \cite{matplotlib}, in special PyPlot was utilized.



\section{Code structure}
For representing hypergraphs, a simple implementation tailored to the requirements was created in order to comfortably being able to implement the graph creation algorithms of \cref{chapter:random_hypergraphs} as well as the small expansion algorithms of \cref{chapter:algorithms}.
Therefore, several classes are used to represent the whole graph.

In order to represent the vertices, the class \textit{vertex} is used. As important attributes, it contains the set of edges it belongs to and the vertices' weight $w_v$ for a vertex $v$. Except for its constructor, the method \textit{add\_to\_edge} is used by the construction algorithms when a new edge, containing $v$, is added. Additionally, for the resampling in \cref{alg:swap_edges}, the method \textit{recompute\_weights\_degrees} is needed to update the attributes of the vertex after an edge is changed.

Edges are represented by the class \textit{edge}, which contains a set of vertices and an attribute \textit{weight} to represent the weight $w_e$ of an edge $e$ and the set of vertices.


Connection components are represented by the class \textit{Connection\_Component}, which contains the set of vertices in that component.

A whole Graph $H$ is encapsulated by the class \textit{Graph}, which contains sets of the vertices as well as edges and, as needed for the construction in \cref{alg:swap_edges}, also a set of the connection components, which are computed by the method \textit{compute\_connection\_components}. This class also contains the algorithms of \cref{chapter:algorithms} and \ref{chapter:random_hypergraphs} as described in \cref{tab:algorithm_implementation_mapping}.

\begin{table}
	\centering
	\begin{tabular}{l| l}
		algorithm & method \\
		\midrule
		\ref{alg:brute_force} & \textit{brute\_force\_hypergraph\_expansion} \\
		\ref{alg:brute_force_size}, \ref{alg:brute_force_size_just_one_side} & \textit{brute\_force\_hypergraph\_expansion\_each\_size}\\
		& (has an option on how to calculate the expansion)\\
		\ref{alg:ses} & \textit{generate\_small\_expansion\_set} \\
		\ref{alg:procedural_minimizer} & \textit{generate\_small\_discrepancy\_ratio\_vertex\_vectors} \\
		\ref{alg:sample_random_vector} & in \textit{generate\_small\_discrepancy\_ratio\_vertex\_vectors} \\
		\ref{alg:small_set_expansion} & \textit{generate\_small\_expansion\_set}   \\
		\ref{alg:orthogonal_separator} & \textit{create\_random\_orthogonal\_seperator} \\
		\ref{alg:sample_assignments} & \textit{assign\_words\_to\_vertices} \\
		\ref{alg:GenerateRandomGraphWithResampling} & \textit{create\_connected\_graph\_random\_edge\_adding\_resampling} \\
		\ref{alg:swap_edges} & \textit{create\_connected\_graph\_low\_degrees\_shuffel\_edges\_until\_connected} \\
		\ref{alg:spanning_tree} & \textit{create\_connected\_graph\_spanning\_tree\_low\_degrees} \\
	
	\end{tabular}
	\caption[Algorithm implementation methods mapping]{Mapping of the algorithms to the respective methods in the implementation.}\label{tab:algorithm_implementation_mapping}
	
\end{table}



Furthermore, to generate small expansions, a static Poisson process in positive as well as negative time is required. Therefore, the class \textit{Poisson\_Process} was created. The constructor takes $\lambda$ and then calculates and holds the times of the events after as well as before the time $t_0=0$. With the method \textit{get\_number\_events\_happened\_until\_t}, the number of events which happened between $t_0$ and the given $t$ is returned. 
For convenient handling of the vectors $f$ generated by \cref{alg:sample_random_vector}, the class \textit{vertex\_vector} is used to access $f(v)$.

In order to evaluate the performance of the various algorithms and to create the plots, several scripts are collected in \textit{evaluation.py}.
After evaluating, the results are saved in a object of class \textit{Graph\_Log}, which contains, among others, the graph, the smallest expansion found by brute-force and the small set expansion found by the approximation algorithm.

The implementation can be found on \href{https://github.com/riegerfr/Bachelor-s-thesis-edge-expansion/tree/master/hypergraph-implementation}{https://github.com/riegerfr/Bachelor-s-thesis-edge-expansion/tree/master/hypergraph-implementation}. %\hyperref{github.com}

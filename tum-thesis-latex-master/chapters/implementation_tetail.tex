\chapter{Implementation}\label{chapter:implementation}

The discussed algorithms were implemented in order to verify the results.
\section{Technologies}
The focus of the implementation was less on performance optimization but on demonstrating feasibility. Therefore, Python 3 (todo: citation) in combination with several libraries was used.
For vector representation and operations, NumPy proved useful and was therefore used. In order to optimize the SDP (todo: cite), the commonly used SciPy was chosen over tools like cvxpy or cvxopt as their implementation proved problematic due to lack of information about them as they are less known.

For storing the results of the evaluation, Pickle was used. In order to create graphs, Matplotlib, in special PyPlot was utilized.



\section{Code}
For representing hypergraphs, a(n?) own implementation was created in order to comfortably being able to implement the graph creation algorithms as well as the small expansion algoeithms.
Therefore, several classes were used to represent the graph.

In order to reprecent the vertices, the class *vertex* is used. As important attributes, it contains the set of edges it belongs to and the vertice's weight $w_v$ for a vertex $v$ (defined like equation ...). Except for its constructor, the method *add\_to\_edge* is used by the construction algorithms when a new edge, containing $v$, is added. Additionally, for the resampling in algorithm ..., the method *recompute\_weights\_degrees* is needed to update the attributes of the vertex after an edge is changed.

Edges are represented by the class *edge*, which contains an attribute *weight* to represent the weight $w_e$ of an edge $e$ and the set of vertices.

A whole Graph $H$ is encapsuled by the class *graph*, which contains sets of the vertices as well as edges and as needed for the graph construction algorithm ... also a set of the connection components of the graph.

Connection components are represented by the class *ConnectionComponent*, which contains the set of vertices in that component.

Furthermore, to generate small expansions, a static poisson process in positive as well as negative time is required. Therefore, the class *Poisson\_Process* was created. The constructor takes $\lambda$ and then calculates the times when the events happened after as well as before the time 0. With the method *get\_number\_events\_happened\_until\_t*, the number of events which happened between $t_0=0$ and the given $t$ is returned. 
For convenient handling of the vectors $f$ generated by \cref{alg:sdp}, *vertex\_vector* is used to access $f(v)$.


The implementation can be found on ... %\hyperref{github.com}
